---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# perinary

<!-- badges: start -->
[![R-CMD-check](https://github.com/bcjaeger/perinary/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/bcjaeger/perinary/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/bcjaeger/perinary/graph/badge.svg)](https://app.codecov.io/gh/bcjaeger/perinary)
<!-- badges: end -->

A grammar for data dictionaries with four primary verbs:

1. `get`: retrieve meta data from a dictionary
1. `set`: modify meta data in a dictionary
1. `infuse`: put meta data from a dictionary into a data frame as an attribute
1. `insert`: put meta data from a dictionary into a data frame as new columns

Dictionaries are often developed outside of a computing session and stored as static files, making it inconvenient to apply meta data from the dictionary to your data. `perinary` aims to bring the magic of a dictionary to your R session, providing intuitive ways to put meta data into your results when you need it.

## Installation

You can install the development version of `perinary` from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("perisphere-rwe/perinary")
```

## Data dictionaries

Dictionaries help organize pertinent information about analytic variables, putting information about each variable into tables and figures using consistent labels and incorporating additional information when appropriate. 

There are two ways to initialize a dictionary. You can build them using `NumericVariable` and `NominalVariable` objects (not shown here, see vignette), but this can be tedious if you have a lot of variables. For most cases, you'll want to use the `as_data_dictionary()` to create a starter dictionary from a given dataset.

```{r, message=FALSE}

library(perinary)
library(tidyverse)
library(palmerpenguins)

data_peng <- penguins %>% 
  select(species, sex, body_mass_g, bill_length_mm, bill_depth_mm)

dd_peng <- as_data_dictionary(data_peng)

dd_peng

```

## Retrieve meta data with `get`

An often overlooked utility of data dictionaries is telling us what we don't know. Our dictionary is initialized, so we'll use the function `get_unknowns()` to tell us what relevant information is missing. This function returns a `tibble` by default, but if you set `as_request = TRUE`, it provides a bullet point list that is easier to read. If you work with subject matter experts, you can also send this text to them and ask for help filling in the gaps.

```{r}
get_unknowns(dd_peng, as_request = TRUE)
```

And if you want to get straight to filling these unknowns in using dictionary functions (described in the next section), `get_unknowns` gives you a full template to fill in when you specify `as_code = TRUE`:

```{r}
get_unknowns(dd_peng, as_code = TRUE)
```

Other `get` functions include 

- `get_term_key()`: returns a `tibble` that links nominal variable categories to modeling terms. This is helpful when you want to incorporate meta information into standard output from modeling functions.

  ```{r}
  get_term_key(dd_peng)
  ```

- `get_dictionary()`: returns a `tibble` containing raw dictionary meta data. This is helpful when you want to apply meta data in a non-standard way.

  ```{r}
  get_dictionary(dd_peng)
  ```

## Modify meta data with `set`

`perinary`'s family of `set` functions provide the interface to modify a dictionary's meta data.

```{r}

dd_peng <- dd_peng %>% 
  set_labels(species = "Species",
             sex = "Sex",
             bill_length_mm = "Bill length",
             bill_depth_mm = "Bill depth") %>% 
  set_units(bill_length_mm = "mm",
            bill_depth_mm = "mm",
            body_mass_g = "grams") %>% 
  set_divby_modeling(bill_length_mm = 5,
                     bill_depth_mm = 5)

```

### Identifier variables

An identifier variable uniquely defines sampling units in a data set. An identifier variable can cause disruption in a data dictionary if it is treated like a factor. For example, we don't want to supply labels for each level of an identifier, and we don't want to summarize data for each level of an identifier. To demonstrate the problem identifiers can pose, here's what would have happened in our call to `get_unknowns()` if we had an unmanaged identifier variable in the dictionary.

```{r}

data_peng %>% 
  mutate(penguid_id = as.character(seq(n()))) %>% 
  as_data_dictionary() %>% 
  get_unknowns(as_request = TRUE)

```

The issue is that we don't want or need to supply category labels for `penguin_id`, so it isn't helpful for these to be included in our list of unknowns. The fix is to designate `penguin_id` (or generally any identifier variables) as an identifier variable, which should take care of all potential downstream issues.

```{r}

data_peng %>% 
  mutate(penguin_id = as.character(seq(n()))) %>% 
  as_data_dictionary() %>% 
  set_identifiers(penguin_id) %>% 
  get_unknowns(as_request = TRUE)

```

### Nominal variables

Modify the category labels for nominal variables with `set_category_labels()`:

```{r}

dd_peng$variables$sex

dd_peng <- dd_peng %>% 
  set_category_labels(sex = c(female = "F", male = "M"))

dd_peng$variables$sex

```

Modify category order for nominal variables with `set_category_order()`:

```{r}

# moves the specified category or categories to the front, putting the 
# remaining categories behind with the same relative order to each other

dd_peng <- dd_peng %>% 
  set_category_order(sex = c("female"))

dd_peng$variables$sex

```

## Apply meta data to attributes with `infuse`

Data dictionaries have a method called `recode()`, which leverages the `dplyr::recode()` function in combination with information stored in the dictionary to provide a 'smart' recoder. The 'smart' part is that this recode function doesn't require you to provide recode values. Instead, it looks for appropriate recode values in the dictionary.

```{r}

# This function is embedded in the dictionary itself, so it's called by 
# typing the name of the dictionary, followed by `$recode(x)`, where 
# `x` is the vector you intend to recode. For example:

data_peng %>% 
  mutate(sex = dd_peng$recode(sex))

```

This works both for variable names and variable categories. For example, pivoting our data to a longer format will move several variable names into a new column called `name`, and this column can be recoded just like we did above.

```{r}

data_peng %>% 
  pivot_longer(starts_with("bill_")) %>% 
  mutate(name = dd_peng$recode(name))

```

If needed, there is a more direct way to get recode information for specific parts of the dictionary:

```{r}

# in case the smart dictionary recoder fails, you can fall back 
# on the more reliable methods get_variable_recoder and 
# get_level_recoder, which are also public methods for dictionaries

recode_bills <- dd_peng$get_variable_recoder(name = c("bill_length_mm",
                                                      "bill_depth_mm"))

recode_sex <- dd_peng$get_level_recoder(name = 'sex')

data_peng %>% 
  pivot_longer(starts_with("bill_")) %>% 
  mutate(name = recode(name, !!!recode_bills),
         sex = recode(sex, !!!recode_sex))

```

### All at once

`infuse_dictionary()` puts all the relevant information from a data dictionary into an existing dataset. This can smooth out your code when you use packages that automatically incorporate labels into their outputs, such as `gtsummary`. In the example below, we infuse our data with the dictionary we created and specify that we want to format continuous variables using their modeling units (e.g., bill length is modeled per 10 mm). Note that when you infuse data with dictionaries and specify `units = 'model'`, the corresponding variables will be divided by their designated `divby_model` value and new columns will be created. If you don't want new columns, you can specify `divby_suffix = NULL` when you infuse.

```{r, eval = FALSE}

library(gtsummary)

data_infused <- data_peng %>% 
  infuse_dictionary(dd_peng, units = 'model', divby_suffix = NULL)

fit <- lm(formula = body_mass_g ~ ., data = data_infused)

tbl_regression(fit)

```

```{r}
knitr::include_graphics('img/screen-regression_table.png')
```

## Example: model fit to table

```{r}

library(broom)

data_infused <- data_peng %>% 
  infuse_dictionary(dd_peng, units = 'model', divby_suffix = NULL)

fit_tidied <- tidy(lm(formula = body_mass_g ~ ., data = data_infused))

insert_term_key(fit_tidied, dictionary = dd_peng)



```



